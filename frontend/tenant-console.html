<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>StaunchBot Tenant Console</title>
  <style>
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: #f5f7fb;
      color: #0f172a;
    }
    .wrap {
      max-width: 1100px;
      margin: 24px auto;
      padding: 0 16px;
    }
    .header {
      margin-bottom: 16px;
    }
    .header h1 {
      margin: 0 0 6px;
      font-size: 24px;
    }
    .header p {
      margin: 0;
      color: #475569;
      font-size: 14px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 14px;
    }
    .card {
      background: #fff;
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      padding: 14px;
      box-shadow: 0 8px 24px rgba(2, 6, 23, 0.05);
    }
    .card h2 {
      font-size: 16px;
      margin: 0 0 10px;
    }
    .row {
      display: grid;
      gap: 8px;
      margin-bottom: 10px;
    }
    label {
      font-size: 12px;
      color: #475569;
      font-weight: 600;
    }
    input, textarea {
      width: 100%;
      padding: 9px 10px;
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      font-size: 14px;
      box-sizing: border-box;
    }
    textarea {
      min-height: 120px;
      resize: vertical;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
    }
    button {
      border: 0;
      border-radius: 8px;
      padding: 9px 12px;
      background: #0f766e;
      color: #fff;
      cursor: pointer;
      font-weight: 600;
    }
    button.alt {
      background: #334155;
    }
    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
    .out {
      margin-top: 8px;
      font-size: 12px;
      background: #0b1220;
      color: #dbeafe;
      border-radius: 8px;
      padding: 10px;
      white-space: pre-wrap;
      min-height: 60px;
    }
    .small {
      font-size: 12px;
      color: #64748b;
    }
    .warn {
      color: #b45309;
    }
    .inline {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .inline > * {
      flex: 1 1 140px;
    }
    .table-wrap {
      overflow: auto;
      border: 1px solid #dbe3ee;
      border-radius: 8px;
      background: #fff;
      margin-top: 10px;
    }
    .kpi-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 8px;
      margin-top: 10px;
    }
    .kpi {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      background: #f8fafc;
      padding: 8px;
    }
    .kpi .k {
      font-size: 11px;
      color: #64748b;
    }
    .kpi .v {
      font-size: 18px;
      font-weight: 800;
      color: #0f172a;
      margin-top: 2px;
    }
    .thread-box {
      border: 1px solid #dbe3ee;
      border-radius: 8px;
      background: #fff;
      padding: 10px;
      max-height: 420px;
      overflow: auto;
      margin-top: 10px;
    }
    .msg {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      background: #f8fafc;
      padding: 8px;
      margin-bottom: 8px;
    }
    .msg .meta {
      font-size: 11px;
      color: #64748b;
      margin-bottom: 6px;
    }
    .msg.user {
      background: #eff6ff;
      border-color: #bfdbfe;
    }
    .msg.assistant {
      background: #ecfeff;
      border-color: #a5f3fc;
    }
    .msg.agent {
      background: #f0fdf4;
      border-color: #bbf7d0;
    }
    .note {
      border: 1px solid #e2e8f0;
      border-radius: 8px;
      background: #f8fafc;
      padding: 8px;
      margin-bottom: 8px;
    }
    .note .meta {
      font-size: 11px;
      color: #64748b;
      margin-bottom: 6px;
    }
    table.queue {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    table.queue th, table.queue td {
      border-bottom: 1px solid #eef2f7;
      padding: 8px;
      text-align: left;
      vertical-align: top;
      white-space: nowrap;
    }
    table.queue th {
      background: #f8fafc;
      color: #334155;
      font-weight: 700;
      position: sticky;
      top: 0;
    }
    .tag {
      display: inline-block;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 11px;
      font-weight: 700;
      border: 1px solid #dbe3ee;
      background: #f8fafc;
    }
    .tag.new { background: #ecfeff; color: #0f766e; border-color: #a5f3fc; }
    .tag.open { background: #eff6ff; color: #1d4ed8; border-color: #bfdbfe; }
    .tag.pending_customer { background: #fff7ed; color: #c2410c; border-color: #fed7aa; }
    .tag.resolved { background: #ecfdf5; color: #15803d; border-color: #bbf7d0; }
    .tag.closed { background: #f1f5f9; color: #334155; border-color: #cbd5e1; }
    .tag.priority.low { background: #f1f5f9; color: #475569; border-color: #cbd5e1; }
    .tag.priority.normal { background: #eff6ff; color: #1d4ed8; border-color: #bfdbfe; }
    .tag.priority.high { background: #fff7ed; color: #c2410c; border-color: #fed7aa; }
    .tag.priority.urgent { background: #fef2f2; color: #b91c1c; border-color: #fecaca; }
    .tag.escalated {
      background: #fef2f2;
      color: #b91c1c;
      border-color: #fecaca;
    }
    .row-action {
      font-size: 11px;
      padding: 5px 8px;
      border-radius: 6px;
      border: 0;
      background: #334155;
      color: #fff;
      cursor: pointer;
    }
    select {
      width: 100%;
      padding: 9px 10px;
      border: 1px solid #cbd5e1;
      border-radius: 8px;
      font-size: 14px;
      box-sizing: border-box;
      background: #fff;
    }
    .sla-breach {
      background: #fff1f2;
    }
    .escalation-row {
      box-shadow: inset 3px 0 0 #dc2626;
      background: #fef2f2;
    }
    .sla-badge {
      display: inline-block;
      font-size: 10px;
      font-weight: 700;
      color: #b91c1c;
      background: #fee2e2;
      border: 1px solid #fecaca;
      border-radius: 999px;
      padding: 1px 6px;
      margin-left: 4px;
    }
    .chart-wrap {
      margin-top: 10px;
      display: grid;
      gap: 10px;
    }
    .chart-box {
      border: 1px solid #dbe3ee;
      border-radius: 8px;
      background: #fff;
      padding: 8px;
    }
    .chart-title {
      font-size: 12px;
      color: #475569;
      margin-bottom: 6px;
      font-weight: 600;
    }
    .chart-svg {
      width: 100%;
      height: 130px;
      display: block;
      background: #f8fafc;
      border-radius: 6px;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 11px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <h1>StaunchBot Tenant Console</h1>
      <p>Self-serve onboarding and tenant operations without Swagger.</p>
      <p class="small">Build: customer-profiles + escalation-ops (2026-03-01)</p>
    </div>

    <div class="grid">
      <section class="card">
        <h2>API + Session</h2>
        <div class="row">
          <label for="apiBase">API Base</label>
          <input id="apiBase" value="https://api.staunchbot.com" />
        </div>
        <div class="row">
          <label for="accessToken">Access Token</label>
          <textarea id="accessToken" placeholder="Bearer token will appear here"></textarea>
        </div>
        <button id="saveToken" class="alt">Save Token</button>
        <button id="clearToken" class="alt">Clear Token</button>
        <div class="small" style="margin-top:8px;">
          Token is stored in browser localStorage for this page only.
        </div>
      </section>

      <section class="card">
        <h2>Tenant Onboard</h2>
        <div class="row"><label>Tenant Name</label><input id="obTenantName" value="Demo Tenant Console" /></div>
        <div class="row"><label>Admin Email</label><input id="obAdminEmail" value="admin-console@demo.com" /></div>
        <div class="row"><label>Admin Password</label><input id="obAdminPassword" value="StrongPass123!" /></div>
        <div class="row"><label>Bot Name</label><input id="obBotName" value="Main Website Bot" /></div>
        <div class="row"><label>Allowed Origins (comma-separated)</label><input id="obAllowedOrigins" value="https://www.staunchbot.com,https://staunchbot.com" /></div>
        <button id="btnOnboard">Run Onboard</button>
        <div id="outOnboard" class="out"></div>
      </section>

      <section class="card">
        <h2>Tenant Login</h2>
        <div class="row"><label>Tenant ID</label><input id="lgTenantId" value="t_demo_3" /></div>
        <div class="row"><label>Email</label><input id="lgEmail" value="admin3@demo.com" /></div>
        <div class="row"><label>Password</label><input id="lgPassword" value="Abc12345!" /></div>
        <button id="btnLogin">Login</button>
        <div id="outLogin" class="out"></div>
      </section>

      <section class="card">
        <h2>Bots</h2>
        <button id="btnBots">Load Bots</button>
        <div id="outBots" class="out"></div>
        <div class="row" style="margin-top:10px;">
          <label>Bot ID for snippet</label>
          <input id="botId" placeholder="bot_..." />
        </div>
        <button id="btnSnippet" class="alt">Get Embed Snippet</button>
        <div id="outSnippet" class="out"></div>
      </section>

      <section class="card">
        <h2>Knowledge Upload + Reindex</h2>
        <div class="row">
          <label>Upload file (.txt, .md, .json, .pdf, .docx)</label>
          <input id="kgFile" type="file" />
        </div>
        <button id="btnUpload">Upload</button>
        <button id="btnStatus" class="alt">Check Status</button>
        <div id="outUpload" class="out"></div>
        <div class="row" style="margin-top:10px;">
          <label>Document ID to reindex</label>
          <input id="kgDocId" placeholder="d_..." />
        </div>
        <button id="btnReindex" class="alt">Reindex</button>
        <div id="outStatus" class="out"></div>
      </section>

      <section class="card">
        <h2>Inbox Queue (Handoff)</h2>
        <div class="row">
          <label>Status Filter</label>
          <select id="hfStatus">
            <option value="">(all)</option>
            <option value="new_open">new + open</option>
            <option value="new">new</option>
            <option value="open">open</option>
            <option value="pending_customer">pending_customer</option>
            <option value="resolved">resolved</option>
            <option value="closed">closed</option>
          </select>
        </div>
        <div class="inline">
          <button id="btnQuickOpenNew" class="alt">Quick: Open/New</button>
          <button id="btnQuickEscalated" class="alt">Quick: Escalated</button>
          <button id="btnQuickResetQueue" class="alt">Quick: Reset</button>
        </div>
        <div class="row">
          <label>Assigned To Filter (user id)</label>
          <input id="hfAssignedTo" placeholder="u_admin_3" />
        </div>
        <div class="inline">
          <div class="row">
            <label>Priority Filter</label>
            <select id="hfPriorityFilter">
              <option value="">(all)</option>
              <option value="low">low</option>
              <option value="normal">normal</option>
              <option value="high">high</option>
              <option value="urgent">urgent</option>
            </select>
          </div>
          <div class="row">
            <label>SLA</label>
            <select id="hfBreachedOnly">
              <option value="false">all</option>
              <option value="true">breached only</option>
            </select>
          </div>
          <div class="row">
            <label>Escalation</label>
            <select id="hfEscalatedOnly">
              <option value="false">all</option>
              <option value="true">escalated only</option>
            </select>
          </div>
        </div>
        <div class="inline">
          <div class="row">
            <label>Sort</label>
            <select id="hfSort">
              <option value="urgent_escalated">urgent/escalated first</option>
              <option value="priority_sla">priority + SLA</option>
              <option value="newest">newest first</option>
            </select>
          </div>
          <div class="row">
            <label>Auto-refresh</label>
            <select id="hfAutoRefresh">
              <option value="0">off</option>
              <option value="5">5s</option>
              <option value="10">10s</option>
              <option value="15">15s</option>
            </select>
          </div>
        </div>
        <button id="btnHandoffList">Load Queue</button>
        <div id="outHandoffList" class="out"></div>
        <div id="queueMetrics" class="kpi-grid" style="display:none;"></div>
        <div id="queueTableWrap" class="table-wrap" style="display:none;">
          <table class="queue" id="queueTable">
            <thead>
              <tr>
                <th>ID</th>
                <th>Status</th>
                <th>Priority</th>
                <th>Source</th>
                <th>Assigned</th>
                <th>Created</th>
                <th>Question</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="queueTableBody"></tbody>
          </table>
        </div>

        <div class="row" style="margin-top:10px;">
          <label>Handoff ID</label>
          <input id="hfId" placeholder="ho_..." />
        </div>
        <div class="inline">
          <div class="row">
            <label>Assign To (user id)</label>
            <input id="hfAssignTo" placeholder="u_admin_3" />
          </div>
          <div class="row">
            <label>Priority</label>
            <select id="hfPriority">
              <option value="">(no change)</option>
              <option value="low">low</option>
              <option value="normal">normal</option>
              <option value="high">high</option>
              <option value="urgent">urgent</option>
            </select>
          </div>
        </div>
        <div class="row">
          <label>Set Status</label>
          <select id="hfSetStatus">
            <option value="">(no change)</option>
            <option value="new">new</option>
            <option value="open">open</option>
            <option value="pending_customer">pending_customer</option>
            <option value="resolved">resolved</option>
            <option value="closed">closed</option>
          </select>
        </div>
        <div class="row">
          <label>Resolution Note</label>
          <input id="hfResolutionNote" placeholder="Resolved after customer confirmation." />
        </div>
        <button id="btnHandoffPatch" class="alt">Patch Handoff</button>
        <div id="outHandoffPatch" class="out"></div>

        <div class="row" style="margin-top:12px;">
          <label>Agent Actions (same handoff)</label>
          <div class="inline">
            <button id="btnHandoffClaim">Claim</button>
            <input id="hfClaimUser" placeholder="claim as user id (optional)" />
          </div>
        </div>
        <div class="row">
          <label>Agent Reply Message</label>
          <textarea id="hfAgentReply" placeholder="Write reply as agent..."></textarea>
        </div>
        <div class="inline">
          <button id="btnReviewReply" class="alt">Review</button>
          <button id="btnRewriteShorter" class="alt">Shorter</button>
          <button id="btnRewriteFriendlier" class="alt">Friendlier</button>
          <button id="btnRewriteFormal" class="alt">Formal</button>
        </div>
        <div class="row">
          <label><input id="hfSendOverride" type="checkbox" style="width:auto; margin-right:6px;" />Send anyway if high-risk flagged</label>
        </div>
        <div id="outReplyReview" class="out"></div>
        <div class="inline">
          <div class="row">
            <label>Mark after reply</label>
            <select id="hfMarkPending">
              <option value="true">pending_customer</option>
              <option value="false">open</option>
            </select>
          </div>
          <div class="row" style="align-self:end;">
            <button id="btnHandoffReply" class="alt">Send Agent Reply</button>
          </div>
        </div>
        <div class="inline">
          <button id="btnPauseAI" class="alt">Pause AI</button>
          <button id="btnResumeAI" class="alt">Resume AI</button>
        </div>
        <div class="row" style="margin-top:10px;">
          <label>Internal Note (private, agent only)</label>
          <textarea id="hfInternalNote" placeholder="Add private context for your team..."></textarea>
        </div>
        <div class="inline">
          <button id="btnAddInternalNote" class="alt">Add Internal Note</button>
          <button id="btnLoadNotes" class="alt">Load Notes</button>
        </div>
        <div id="outHandoffAgent" class="out"></div>
        <div id="notesTimeline" class="thread-box" style="display:none;"></div>

        <div class="row" style="margin-top:12px;">
          <label>Conversation ID</label>
          <div class="inline">
            <input id="convId" placeholder="conv_..." />
            <button id="btnLoadConversation" class="alt">Load Thread</button>
          </div>
          <div class="small">Selecting a queue row auto-fills this if available.</div>
        </div>
        <div id="outConversationMeta" class="out"></div>
        <div id="conversationThread" class="thread-box" style="display:none;"></div>
      </section>

      <section class="card">
        <h2>Customer Profiles</h2>
        <div class="small">View linked customer identities across channels and merge duplicates.</div>
        <div class="inline" style="margin-top:10px;">
          <div class="row">
            <label>Limit</label>
            <input id="cpLimit" value="100" />
          </div>
          <div class="row" style="align-self:end;">
            <button id="btnProfilesList">Load Profiles</button>
          </div>
        </div>
        <div id="outProfilesList" class="out"></div>
        <div id="profilesTableWrap" class="table-wrap" style="display:none;">
          <table class="queue">
            <thead>
              <tr>
                <th>Profile</th>
                <th>Display</th>
                <th>Handles</th>
                <th>Conversations</th>
                <th>Handoffs</th>
                <th>Updated</th>
                <th>Action</th>
              </tr>
            </thead>
            <tbody id="profilesTableBody"></tbody>
          </table>
        </div>
        <div class="inline" style="margin-top:10px;">
          <div class="row">
            <label>Source Profile ID</label>
            <input id="cpSourceId" placeholder="cp_..." />
          </div>
          <div class="row">
            <label>Target Profile ID</label>
            <input id="cpTargetId" placeholder="cp_..." />
          </div>
        </div>
        <div class="inline">
          <button id="btnProfilesMerge" class="alt">Merge Profiles</button>
          <button id="btnQaMergeFlow" class="alt">QA Merge Flow</button>
        </div>
        <div class="row" style="margin-top:10px;">
          <label>Merge Reason (required)</label>
          <input id="cpMergeReason" placeholder="duplicate handles from same customer across channels" />
        </div>
        <div id="outProfilesMerge" class="out"></div>
        <div class="row" style="margin-top:10px;">
          <label>Profile Seed (via inbound webhook simulation)</label>
          <div class="inline">
            <input id="cpSeedExternalId" placeholder="ext_customer_1001" />
            <input id="cpSeedMessage" value="I need human support with my order." />
          </div>
        </div>
        <div class="inline">
          <button id="btnSeedProfileData" class="alt">Seed Profile Activity</button>
        </div>
        <div id="outProfileSeed" class="out"></div>
      </section>

      <section class="card">
        <h2>Escalation Ops</h2>
        <div class="small">Run SLA escalation sweep and inspect escalation KPIs.</div>
        <div id="qaEnvBanner" class="small warn" style="display:none;margin-top:6px;">QA flow buttons are disabled on production API base.</div>
        <div class="inline" style="margin-top:10px;">
          <button id="btnEscMetrics">Load Escalation Metrics</button>
          <button id="btnEscSweep" class="alt">Run Escalation Sweep</button>
          <button id="btnQaSweepFlow" class="alt">QA Sweep Flow</button>
        </div>
        <div class="row" style="margin-top:10px;">
          <label>Sweep Reason (required)</label>
          <input id="escSweepReason" placeholder="scheduled SLA breach triage" />
        </div>
        <div id="outEscalationOps" class="out"></div>
        <div id="escMetricsGrid" class="kpi-grid" style="display:none;"></div>
        <div class="row" style="margin-top:10px;">
          <label>Ops Monitoring</label>
          <div class="inline">
            <button id="btnLoadOpsMonitor" class="alt">Load Ops Monitor</button>
          </div>
        </div>
        <div id="opsMonitorGrid" class="kpi-grid" style="display:none;"></div>
        <div class="row" style="margin-top:10px;">
          <label>Ops Audit Trail (local)</label>
          <button id="btnLoadOpsAudit" class="alt">Refresh Audit Trail</button>
        </div>
        <div id="outOpsAudit" class="out"></div>
      </section>

      <section class="card">
        <h2>Productivity Metrics</h2>
        <button id="btnLoadProdMetrics">Load Metrics</button>
        <div id="outProdMetrics" class="out"></div>
        <div id="prodMetricsGrid" class="kpi-grid" style="display:none;"></div>
        <div id="prodCharts" class="chart-wrap" style="display:none;">
          <div class="chart-box">
            <div class="chart-title">Resolved vs Unresolved vs All</div>
            <svg id="chartResolvedSplit" class="chart-svg" viewBox="0 0 600 130" preserveAspectRatio="none"></svg>
          </div>
          <div class="chart-box">
            <div class="chart-title">7-day Ticket Volume</div>
            <svg id="chartTickets" class="chart-svg" viewBox="0 0 600 130" preserveAspectRatio="none"></svg>
          </div>
          <div class="chart-box">
            <div class="chart-title">7-day Breach Rate</div>
            <svg id="chartBreach" class="chart-svg" viewBox="0 0 600 130" preserveAspectRatio="none"></svg>
          </div>
          <div class="chart-box">
            <div class="chart-title">Top Agent Workload</div>
            <svg id="chartAgents" class="chart-svg" viewBox="0 0 600 130" preserveAspectRatio="none"></svg>
          </div>
        </div>
        <div id="prodAgentWrap" class="table-wrap" style="display:none;">
          <table class="queue">
            <thead>
              <tr>
                <th>Agent</th>
                <th>Assigned</th>
                <th>Resolved</th>
              </tr>
            </thead>
            <tbody id="prodAgentBody"></tbody>
          </table>
        </div>
      </section>
    </div>

    <p class="small warn" style="margin-top:14px;">
      Use this console for development/admin flows. For production tenant UX, add proper auth UI, validation, and rate limiting.
    </p>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);
    let queueTimer = null;
    let lastReplyReview = null;
    let lastQueueItems = [];
    let lastProfiles = [];
    let lastSweepRun = null;

    function pretty(v) {
      try { return JSON.stringify(v, null, 2); } catch (_) { return String(v); }
    }

    function getApiBase() {
      return $("apiBase").value.trim().replace(/\/+$/, "");
    }

    function isProdApiBase() {
      const base = getApiBase().toLowerCase();
      return base.includes("api.staunchbot.com") || base.includes("railway.app");
    }

    function nowIso() {
      return new Date().toISOString();
    }

    function safeJwtField(index) {
      const token = getToken().replace(/^Bearer\s+/i, "");
      const parts = token.split(".");
      if (parts.length < 2) return null;
      try {
        const b64 = parts[index].replace(/-/g, "+").replace(/_/g, "/");
        const json = atob(b64);
        return JSON.parse(json);
      } catch (_) {
        return null;
      }
    }

    function currentActorId() {
      const claims = safeJwtField(1) || {};
      return claims.sub || claims.email || "unknown_actor";
    }

    function appendOpsAudit(entry) {
      try {
        const raw = localStorage.getItem("tenant_console_ops_audit");
        const parsed = JSON.parse(raw || "[]");
        const list = Array.isArray(parsed) ? parsed : [];
        list.unshift(entry);
        const trimmed = list.slice(0, 100);
        localStorage.setItem("tenant_console_ops_audit", JSON.stringify(trimmed));
      } catch (_) {}
    }

    function loadOpsAudit() {
      const out = $("outOpsAudit");
      try {
        const raw = localStorage.getItem("tenant_console_ops_audit");
        const parsed = JSON.parse(raw || "[]");
        const list = Array.isArray(parsed) ? parsed : [];
        out.textContent = pretty({ count: list.length, items: list.slice(0, 25) });
      } catch (e) {
        out.textContent = String(e);
      }
    }

    function requireReasonAndConfirm(reasonText, actionLabel) {
      const reason = String(reasonText || "").trim();
      if (reason.length < 8) {
        throw new Error("Provide a reason (at least 8 chars) before running this action.");
      }
      const ok = window.confirm(`${actionLabel}\n\nReason: ${reason}\n\nProceed?`);
      if (!ok) throw new Error("Action canceled by operator.");
      return reason;
    }

    function getToken() {
      return $("accessToken").value.trim();
    }

    function setToken(token) {
      $("accessToken").value = token || "";
    }

    async function request(path, options = {}) {
      const headers = Object.assign({}, options.headers || {});
      const token = getToken();
      if (token) headers.Authorization = `Bearer ${token.replace(/^Bearer\s+/i, "")}`;
      const res = await fetch(`${getApiBase()}${path}`, { ...options, headers });
      const text = await res.text();
      let data = text;
      try { data = JSON.parse(text); } catch (_) {}
      if (!res.ok) throw new Error(`${res.status} ${pretty(data)}`);
      return data;
    }

    function parseOrigins(s) {
      return String(s || "").split(",").map(v => v.trim()).filter(Boolean);
    }

    function esc(s) {
      return String(s == null ? "" : s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function shortDate(iso) {
      if (!iso) return "-";
      const d = new Date(iso);
      if (Number.isNaN(d.getTime())) return iso;
      return d.toLocaleString();
    }

    function renderQueueTable(items) {
      const wrap = $("queueTableWrap");
      const body = $("queueTableBody");
      body.innerHTML = "";
      if (!Array.isArray(items) || !items.length) {
        wrap.style.display = "none";
        return;
      }
      wrap.style.display = "block";
      for (const item of items) {
        const tr = document.createElement("tr");
        const statusClass = esc(item.status || "");
        const firstBreached = !!(item.first_response_due_at && !item.first_responded_at && ["new", "open"].includes(item.status));
        const resolutionBreached = !!(item.resolution_due_at && ["open", "pending_customer"].includes(item.status));
        const isBreached = firstBreached || resolutionBreached;
        const isEscalated = !!item.escalation_flag;
        if (isBreached) tr.className = "sla-breach";
        if (isEscalated) tr.className = `${tr.className ? `${tr.className} ` : ""}escalation-row`;
        const priority = String(item.priority || "").toLowerCase();
        const breachBadges = [
          firstBreached ? '<span class="sla-badge">first response breached</span>' : "",
          resolutionBreached ? '<span class="sla-badge">resolution breached</span>' : "",
        ].filter(Boolean).join(" ");
        const escalationBadge = isEscalated
          ? `<span class="tag escalated" title="${esc(shortDate(item.escalated_at))}">escalated</span>`
          : "";
        const priorityBadge = `<span class="tag priority ${esc(priority)}">${esc(item.priority || "-")}</span>`;
        tr.innerHTML = `
          <td title="${esc(item.id)}">${esc(item.id || "-")}</td>
          <td><span class="tag ${statusClass}">${esc(item.status || "-")}</span>${breachBadges ? `<div style="margin-top:4px;">${breachBadges}</div>` : ""}</td>
          <td>${priorityBadge}${escalationBadge ? `<div style="margin-top:4px;">${escalationBadge}${priority === "urgent" ? '<span class="sla-badge">priority bumped</span>' : ""}</div>` : ""}</td>
          <td>${esc(item.source_channel || "-")}</td>
          <td>${esc(item.assigned_to_user_id || "-")}</td>
          <td>${esc(shortDate(item.created_at))}</td>
          <td title="${esc(item.question || "")}" style="max-width:280px;white-space:normal;">${esc(item.question || "-")}</td>
          <td><button class="row-action" data-hid="${esc(item.id || "")}">Use</button></td>
        `;
        body.appendChild(tr);
      }
      body.querySelectorAll("button[data-hid]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const handoffId = btn.getAttribute("data-hid") || "";
          $("hfId").value = handoffId;
          const selected = (items || []).find((x) => x.id === handoffId);
          if (selected && selected.conversation_id) {
            $("convId").value = selected.conversation_id;
          }
          $("outHandoffAgent").textContent = `Selected handoff: ${$("hfId").value}`;
          $("btnLoadNotes").click();
        });
      });
    }

    function queueMetrics(items) {
      const rows = Array.isArray(items) ? items : [];
      const byStatus = { new: 0, open: 0, pending_customer: 0, resolved: 0, closed: 0 };
      let breached = 0;
      let unassigned = 0;
      let escalated = 0;
      for (const x of rows) {
        const s = String(x.status || "");
        if (Object.prototype.hasOwnProperty.call(byStatus, s)) byStatus[s] += 1;
        if (!x.assigned_to_user_id) unassigned += 1;
        if (isSlaBreached(x)) breached += 1;
        if (x.escalation_flag) escalated += 1;
      }
      return { total: rows.length, breached, unassigned, escalated, ...byStatus };
    }

    function renderQueueMetrics(items) {
      const box = $("queueMetrics");
      const m = queueMetrics(items);
      if (!m.total) {
        box.style.display = "none";
        box.innerHTML = "";
        return;
      }
      box.style.display = "grid";
      const cards = [
        ["Total", m.total],
        ["New", m.new],
        ["Open", m.open],
        ["Pending", m.pending_customer],
        ["Resolved", m.resolved],
        ["Closed", m.closed],
        ["Breached", m.breached],
        ["Escalated", m.escalated],
        ["Unassigned", m.unassigned],
      ];
      box.innerHTML = cards.map(([k, v]) => `<div class="kpi"><div class="k">${esc(k)}</div><div class="v">${esc(v)}</div></div>`).join("");
    }

    function renderProfilesTable(data) {
      const wrap = $("profilesTableWrap");
      const body = $("profilesTableBody");
      body.innerHTML = "";
      const profiles = Array.isArray(data && data.profiles) ? data.profiles : [];
      lastProfiles = profiles;
      if (!profiles.length) {
        wrap.style.display = "none";
        return;
      }
      wrap.style.display = "block";
      body.innerHTML = profiles.map((p) => {
        const handles = Array.isArray(p.handles) ? p.handles : [];
        const handleText = handles.length
          ? handles.map((h) => `${h.channel_type}:${h.external_user_id}`).join(", ")
          : "-";
        return `
          <tr>
            <td class="mono">${esc(p.id || "-")}</td>
            <td>${esc(p.display_name || "-")}</td>
            <td title="${esc(handleText)}" style="max-width:320px;white-space:normal;">${esc(handleText)}</td>
            <td>${esc(p.conversation_count || 0)}</td>
            <td>${esc(p.handoff_count || 0)}</td>
            <td>${esc(shortDate(p.updated_at))}</td>
            <td>
              <button class="row-action" data-cp-source="${esc(p.id || "")}">Source</button>
              <button class="row-action" data-cp-target="${esc(p.id || "")}">Target</button>
            </td>
          </tr>
        `;
      }).join("");
      body.querySelectorAll("button[data-cp-source]").forEach((btn) => {
        btn.addEventListener("click", () => {
          $("cpSourceId").value = btn.getAttribute("data-cp-source") || "";
        });
      });
      body.querySelectorAll("button[data-cp-target]").forEach((btn) => {
        btn.addEventListener("click", () => {
          $("cpTargetId").value = btn.getAttribute("data-cp-target") || "";
        });
      });
    }

    function renderEscalationMetricsCards(data) {
      const box = $("escMetricsGrid");
      if (!data || !data.window_24h || !data.window_7d || !data.totals) {
        box.style.display = "none";
        box.innerHTML = "";
        return;
      }
      const w24 = data.window_24h;
      const w7d = data.window_7d;
      const t = data.totals;
      const cards = [
        ["Escalated (total)", t.escalated_tickets ?? "-"],
        ["24h Escalation %", `${((w24.escalation_rate || 0) * 100).toFixed(1)}%`],
        ["7d Escalation %", `${((w7d.escalation_rate || 0) * 100).toFixed(1)}%`],
        ["24h Breach %", `${((w24.breach_rate || 0) * 100).toFixed(1)}%`],
        ["7d Breach %", `${((w7d.breach_rate || 0) * 100).toFixed(1)}%`],
        ["As Of", shortDate(data.as_of)],
      ];
      box.style.display = "grid";
      box.innerHTML = cards.map(([k, v]) => `<div class="kpi"><div class="k">${esc(k)}</div><div class="v">${esc(v)}</div></div>`).join("");
    }

    function renderOpsMonitorGrid(metricsData, queueItems) {
      const box = $("opsMonitorGrid");
      const items = Array.isArray(queueItems) ? queueItems : [];
      const urgentBacklog = items.filter((x) => String(x.priority || "").toLowerCase() === "urgent" && ["new", "open", "pending_customer"].includes(String(x.status || ""))).length;
      const escalatedOpen = items.filter((x) => x.escalation_flag && ["new", "open", "pending_customer"].includes(String(x.status || ""))).length;
      const m = metricsData || {};
      const t = m.totals || {};
      const w24 = m.window_24h || {};
      const cards = [
        ["Urgent Backlog", urgentBacklog],
        ["Escalated Open", escalatedOpen],
        ["Escalated Total", t.escalated_tickets ?? "-"],
        ["24h Escalation %", w24.escalation_rate != null ? `${(Number(w24.escalation_rate) * 100).toFixed(1)}%` : "-"],
        ["24h Tickets", w24.total_tickets ?? "-"],
        ["Last Sweep", lastSweepRun ? shortDate(lastSweepRun.at) : "never"],
      ];
      box.style.display = "grid";
      box.innerHTML = cards.map(([k, v]) => `<div class="kpi"><div class="k">${esc(k)}</div><div class="v">${esc(v)}</div></div>`).join("");
    }

    function applyQaAvailability() {
      const isProd = isProdApiBase();
      const qaBtns = ["btnQaSweepFlow", "btnQaMergeFlow"];
      for (const id of qaBtns) {
        const el = $(id);
        if (el) el.disabled = isProd;
      }
      $("qaEnvBanner").style.display = isProd ? "block" : "none";
    }

    function renderProductivityMetrics(data) {
      const grid = $("prodMetricsGrid");
      const body = $("prodAgentBody");
      const wrap = $("prodAgentWrap");
      const charts = $("prodCharts");
      if (!data || !data.window_24h || !data.window_7d) {
        grid.style.display = "none";
        grid.innerHTML = "";
        charts.style.display = "none";
        wrap.style.display = "none";
        body.innerHTML = "";
        return;
      }

      const w24 = data.window_24h;
      const w7d = data.window_7d;
      const totals = data.totals || {};
      const cards = [
        ["All Tickets", totals.all_tickets ?? "-"],
        ["Resolved", totals.resolved_tickets ?? "-"],
        ["Unresolved", totals.unresolved_tickets ?? "-"],
        ["Resolved %", totals.resolved_rate != null ? `${(totals.resolved_rate * 100).toFixed(1)}%` : "-"],
        ["24h Tickets", w24.total_tickets],
        ["24h Breach %", `${(w24.breach_rate * 100).toFixed(1)}%`],
        ["24h First Resp (min)", w24.avg_first_response_min ?? "-"],
        ["24h Resolution (min)", w24.avg_resolution_min ?? "-"],
        ["7d Tickets", w7d.total_tickets],
        ["7d Breach %", `${(w7d.breach_rate * 100).toFixed(1)}%`],
        ["7d First Resp (min)", w7d.avg_first_response_min ?? "-"],
        ["7d Resolution (min)", w7d.avg_resolution_min ?? "-"],
      ];
      grid.style.display = "grid";
      grid.innerHTML = cards.map(([k, v]) => `<div class="kpi"><div class="k">${esc(k)}</div><div class="v">${esc(v)}</div></div>`).join("");
      charts.style.display = "grid";
      renderProdCharts(data);

      const agents = Array.isArray(data.by_agent) ? data.by_agent : [];
      if (!agents.length) {
        wrap.style.display = "none";
        body.innerHTML = "";
        return;
      }
      wrap.style.display = "block";
      body.innerHTML = agents.map((a) => `
        <tr>
          <td>${esc(a.agent_user_id || "-")}</td>
          <td>${esc(a.assigned_count || 0)}</td>
          <td>${esc(a.resolved_count || 0)}</td>
        </tr>
      `).join("");
    }

    function renderLineSvg(svgId, values, color, yLabelSuffix = "") {
      const svg = $(svgId);
      if (!svg) return;
      const w = 600;
      const h = 130;
      const pad = 18;
      const maxV = Math.max(1, ...values);
      const n = values.length;
      const step = n > 1 ? (w - pad * 2) / (n - 1) : 0;
      const points = values.map((v, i) => {
        const x = pad + i * step;
        const y = h - pad - ((v / maxV) * (h - pad * 2));
        return `${x},${y}`;
      }).join(" ");
      const circles = values.map((v, i) => {
        const x = pad + i * step;
        const y = h - pad - ((v / maxV) * (h - pad * 2));
        return `<circle cx="${x}" cy="${y}" r="2.5" fill="${color}"></circle>`;
      }).join("");
      svg.innerHTML = `
        <line x1="${pad}" y1="${h - pad}" x2="${w - pad}" y2="${h - pad}" stroke="#cbd5e1" stroke-width="1"></line>
        <line x1="${pad}" y1="${pad}" x2="${pad}" y2="${h - pad}" stroke="#cbd5e1" stroke-width="1"></line>
        <polyline fill="none" stroke="${color}" stroke-width="2.5" points="${points}"></polyline>
        ${circles}
        <text x="${w - pad}" y="${pad}" text-anchor="end" fill="#64748b" font-size="10">max ${maxV}${yLabelSuffix}</text>
      `;
    }

    function renderBarSvg(svgId, values, labels, color) {
      const svg = $(svgId);
      if (!svg) return;
      const w = 600;
      const h = 130;
      const pad = 18;
      const maxV = Math.max(1, ...values);
      const n = Math.max(1, values.length);
      const slot = (w - pad * 2) / n;
      const barW = Math.max(8, slot * 0.6);
      const bars = values.map((v, i) => {
        const bh = (v / maxV) * (h - pad * 2);
        const x = pad + i * slot + (slot - barW) / 2;
        const y = h - pad - bh;
        const lab = esc(String(labels[i] || ""));
        return `<rect x="${x}" y="${y}" width="${barW}" height="${bh}" fill="${color}" rx="2"></rect>
                <title>${lab}: ${v}</title>`;
      }).join("");
      svg.innerHTML = `
        <line x1="${pad}" y1="${h - pad}" x2="${w - pad}" y2="${h - pad}" stroke="#cbd5e1" stroke-width="1"></line>
        ${bars}
        <text x="${w - pad}" y="${pad}" text-anchor="end" fill="#64748b" font-size="10">max ${maxV}</text>
      `;
    }

    function renderProdCharts(data) {
      const totals = data.totals || {};
      const splitVals = [
        Number(totals.resolved_tickets || 0),
        Number(totals.unresolved_tickets || 0),
        Number(totals.all_tickets || 0),
      ];
      renderBarSvg("chartResolvedSplit", splitVals, ["Resolved", "Unresolved", "All"], "#7c3aed");

      const daily = Array.isArray(data.daily) ? data.daily : [];
      const ticketSeries = daily.map((d) => Number(d.tickets || 0));
      const breachSeries = daily.map((d) => Number(d.breach_rate || 0) * 100);
      renderLineSvg("chartTickets", ticketSeries.length ? ticketSeries : [0], "#1d4ed8");
      renderLineSvg("chartBreach", breachSeries.length ? breachSeries : [0], "#b91c1c", "%");

      const agents = (Array.isArray(data.by_agent) ? data.by_agent : []).slice(0, 8);
      const agentVals = agents.map((a) => Number(a.assigned_count || 0));
      const agentLabs = agents.map((a) => String(a.agent_user_id || "-"));
      renderBarSvg("chartAgents", agentVals.length ? agentVals : [0], agentLabs.length ? agentLabs : ["-"], "#0f766e");
    }

    function roleClass(role) {
      const r = String(role || "").toLowerCase();
      if (r === "user") return "user";
      if (r === "assistant") return "assistant";
      if (r === "agent") return "agent";
      return "";
    }

    function renderConversationThread(payload) {
      const box = $("conversationThread");
      if (!payload || !Array.isArray(payload.messages) || !payload.messages.length) {
        box.style.display = "none";
        box.innerHTML = "";
        return;
      }
      box.style.display = "block";
      box.innerHTML = payload.messages.map((m) => {
        const role = esc(m.role || "unknown");
        return `
          <div class="msg ${roleClass(m.role)}">
            <div class="meta">${role} - ${esc(shortDate(m.created_at))}</div>
            <div>${esc(m.content || "")}</div>
          </div>
        `;
      }).join("");
      box.scrollTop = box.scrollHeight;
    }

    function renderNotesTimeline(payload) {
      const box = $("notesTimeline");
      if (!payload || !Array.isArray(payload.items) || !payload.items.length) {
        box.style.display = "none";
        box.innerHTML = "";
        return;
      }
      box.style.display = "block";
      box.innerHTML = payload.items.map((n) => {
        return `
          <div class="note">
            <div class="meta">${esc(n.author_user_id || "-")} - ${esc(shortDate(n.created_at))}</div>
            <div>${esc(n.content || "")}</div>
          </div>
        `;
      }).join("");
      box.scrollTop = box.scrollHeight;
    }

    async function loadHandoffNotes() {
      const handoffId = $("hfId").value.trim();
      if (!handoffId) throw new Error("Provide handoff id.");
      const data = await request(`/api/v1/admin/handoff/${encodeURIComponent(handoffId)}/notes?limit=200&offset=0`);
      renderNotesTimeline(data);
      return data;
    }

    function renderReplyReview(data) {
      const out = $("outReplyReview");
      if (!data) {
        out.textContent = "";
        return;
      }
      out.textContent = pretty({
        handoff_id: data.handoff_id,
        confidence: data.confidence,
        requires_override: data.requires_override,
        risk_flags: data.risk_flags || [],
      });
    }

    async function fetchReplyReview(mode = "none") {
      const handoffId = $("hfId").value.trim();
      if (!handoffId) throw new Error("Provide handoff id.");
      const draft = $("hfAgentReply").value.trim();
      if (!draft) throw new Error("Write an agent reply first.");
      const data = await request(`/api/v1/admin/handoff/reply-review`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          handoff_id: handoffId,
          draft,
          rewrite_mode: mode,
        }),
      });
      lastReplyReview = {
        handoff_id: handoffId,
        draft_before_send: draft,
        requires_override: !!data.requires_override,
        confidence: data.confidence,
      };
      return data;
    }

    function priorityRank(priority) {
      const p = String(priority || "").toLowerCase();
      if (p === "urgent") return 4;
      if (p === "high") return 3;
      if (p === "normal") return 2;
      if (p === "low") return 1;
      return 0;
    }

    function isSlaBreached(item) {
      const firstBreached = !!(item.first_response_due_at && !item.first_responded_at && ["new", "open"].includes(item.status));
      const resolutionBreached = !!(item.resolution_due_at && ["open", "pending_customer"].includes(item.status));
      return firstBreached || resolutionBreached;
    }

    function sortQueueItems(items) {
      const mode = $("hfSort").value;
      const arr = Array.isArray(items) ? [...items] : [];
      if (mode === "newest") {
        return arr.sort((a, b) => new Date(b.created_at || 0) - new Date(a.created_at || 0));
      }
      if (mode === "urgent_escalated") {
        return arr.sort((a, b) => {
          const escDiff = Number(!!b.escalation_flag) - Number(!!a.escalation_flag);
          if (escDiff !== 0) return escDiff;
          const urgentDiff = Number(String(b.priority || "").toLowerCase() === "urgent") - Number(String(a.priority || "").toLowerCase() === "urgent");
          if (urgentDiff !== 0) return urgentDiff;
          const highDiff = Number(String(b.priority || "").toLowerCase() === "high") - Number(String(a.priority || "").toLowerCase() === "high");
          if (highDiff !== 0) return highDiff;
          const breachDiff = Number(isSlaBreached(b)) - Number(isSlaBreached(a));
          if (breachDiff !== 0) return breachDiff;
          return new Date(b.created_at || 0) - new Date(a.created_at || 0);
        });
      }
      return arr.sort((a, b) => {
        const breachDiff = Number(isSlaBreached(b)) - Number(isSlaBreached(a));
        if (breachDiff !== 0) return breachDiff;
        const prioDiff = priorityRank(b.priority) - priorityRank(a.priority);
        if (prioDiff !== 0) return prioDiff;
        return new Date(b.created_at || 0) - new Date(a.created_at || 0);
      });
    }

    function setQueueAutoRefresh() {
      if (queueTimer) {
        clearInterval(queueTimer);
        queueTimer = null;
      }
      const seconds = parseInt($("hfAutoRefresh").value, 10) || 0;
      if (seconds > 0) {
        queueTimer = setInterval(() => {
          loadHandoffQueue(true);
        }, seconds * 1000);
      }
    }

    async function loadHandoffQueue(silent = false) {
      const out = $("outHandoffList");
      if (!silent) out.textContent = "Loading queue...";
      try {
        const params = new URLSearchParams();
        const status = $("hfStatus").value.trim();
        const assignedTo = $("hfAssignedTo").value.trim();
        const priority = $("hfPriorityFilter").value.trim();
        const breachedOnly = $("hfBreachedOnly").value === "true";
        const escalatedOnly = $("hfEscalatedOnly").value === "true";
        if (status && status !== "new_open") params.set("status", status);
        if (assignedTo) params.set("assigned_to", assignedTo);
        if (priority) params.set("priority", priority);
        if (breachedOnly) params.set("breached_only", "true");
        const query = params.toString() ? `?${params.toString()}` : "";
        const data = await request(`/api/v1/admin/handoff${query}`);
        let items = Array.isArray(data && data.items) ? data.items : [];
        if (status === "new_open") {
          items = items.filter((x) => ["new", "open"].includes(String(x.status || "")));
        }
        if (escalatedOnly) {
          items = items.filter((x) => !!x.escalation_flag);
        }
        items = sortQueueItems(items);
        lastQueueItems = items;
        if (!silent) out.textContent = pretty({ ...data, items });
        renderQueueMetrics(items);
        renderQueueTable(items);
        if (items.length && items[0].id && !$("hfId").value.trim()) {
          $("hfId").value = items[0].id;
        }
      } catch (e) {
        out.textContent = String(e);
        lastQueueItems = [];
        renderQueueMetrics([]);
        renderQueueTable([]);
      }
    }

    async function loadProfiles() {
      const out = $("outProfilesList");
      out.textContent = "Loading profiles...";
      try {
        const limit = Math.max(1, Math.min(500, parseInt($("cpLimit").value, 10) || 100));
        const data = await request(`/api/v1/admin/channels/profiles?limit=${limit}`);
        out.textContent = pretty({ tenant_id: data.tenant_id, count: Array.isArray(data.profiles) ? data.profiles.length : 0 });
        renderProfilesTable(data);
        return data;
      } catch (e) {
        out.textContent = String(e);
        renderProfilesTable(null);
        throw e;
      }
    }

    async function mergeProfiles() {
      const out = $("outProfilesMerge");
      out.textContent = "Merging profiles...";
      try {
        const source = $("cpSourceId").value.trim();
        const target = $("cpTargetId").value.trim();
        if (!source || !target) throw new Error("Provide both source and target profile IDs.");
        const reason = requireReasonAndConfirm($("cpMergeReason").value, "Merge customer profiles");
        const data = await request("/api/v1/admin/channels/profiles/merge", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ source_profile_id: source, target_profile_id: target }),
        });
        appendOpsAudit({
          at: nowIso(),
          actor: currentActorId(),
          operation: "profiles.merge",
          reason,
          source_profile_id: source,
          target_profile_id: target,
          result: data,
        });
        out.textContent = pretty(data);
        await loadProfiles();
        loadOpsAudit();
        return data;
      } catch (e) {
        out.textContent = String(e);
        throw e;
      }
    }

    async function loadEscalationMetrics() {
      const out = $("outEscalationOps");
      out.textContent = "Loading escalation metrics...";
      try {
        const data = await request("/api/v1/admin/handoff/metrics");
        out.textContent = pretty({ tenant_id: data.tenant_id, as_of: data.as_of, escalated_total: data.totals && data.totals.escalated_tickets });
        renderEscalationMetricsCards(data);
        return data;
      } catch (e) {
        out.textContent = String(e);
        renderEscalationMetricsCards(null);
        throw e;
      }
    }

    async function runEscalationSweep() {
      const out = $("outEscalationOps");
      out.textContent = "Running escalation sweep...";
      try {
        const reason = requireReasonAndConfirm($("escSweepReason").value, "Run escalation sweep");
        const data = await request("/api/v1/admin/handoff/escalation/sweep", { method: "POST" });
        lastSweepRun = {
          at: nowIso(),
          result: data,
        };
        appendOpsAudit({
          at: nowIso(),
          actor: currentActorId(),
          operation: "handoff.escalation_sweep",
          reason,
          result: data,
        });
        out.textContent = pretty(data);
        await loadHandoffQueue(true);
        const metrics = await loadEscalationMetrics();
        renderOpsMonitorGrid(metrics, lastQueueItems);
        loadOpsAudit();
        return data;
      } catch (e) {
        out.textContent = String(e);
        throw e;
      }
    }

    async function loadOpsMonitor() {
      const out = $("outEscalationOps");
      out.textContent = "Loading ops monitor...";
      try {
        await loadHandoffQueue(true);
        const metrics = await request("/api/v1/admin/handoff/metrics");
        renderEscalationMetricsCards(metrics);
        renderOpsMonitorGrid(metrics, lastQueueItems);
        out.textContent = pretty({
          tenant_id: metrics.tenant_id,
          as_of: metrics.as_of,
          urgent_backlog: (lastQueueItems || []).filter((x) => String(x.priority || "").toLowerCase() === "urgent" && ["new", "open", "pending_customer"].includes(String(x.status || ""))).length,
          escalated_open: (lastQueueItems || []).filter((x) => !!x.escalation_flag && ["new", "open", "pending_customer"].includes(String(x.status || ""))).length,
          last_sweep_at: lastSweepRun ? lastSweepRun.at : null,
        });
      } catch (e) {
        out.textContent = String(e);
      }
    }

    async function seedProfileActivity() {
      const out = $("outProfileSeed");
      out.textContent = "Seeding profile activity...";
      try {
        const externalId = $("cpSeedExternalId").value.trim() || `ext_customer_${Date.now()}`;
        const message = $("cpSeedMessage").value.trim() || "I need human support with my order.";
        const accounts = await request("/api/v1/admin/channels/accounts");
        const pageLike = (Array.isArray(accounts) ? accounts : []).find((a) =>
          ["messenger", "facebook", "instagram"].includes(String(a.channel_type || "").toLowerCase()) &&
          (a.page_id || a.instagram_account_id)
        );
        if (!pageLike) {
          throw new Error("No messenger/facebook/instagram channel account with page_id/instagram_account_id found. Configure one first.");
        }
        const recipientId = pageLike.page_id || pageLike.instagram_account_id;
        const objectType = String(pageLike.channel_type || "").toLowerCase() === "instagram" ? "instagram" : "page";
        const payload = {
          object: objectType,
          entry: [
            {
              id: "seed_entry",
              time: Date.now(),
              messaging: [
                {
                  sender: { id: externalId },
                  recipient: { id: recipientId },
                  timestamp: Date.now(),
                  message: { mid: `seed_${Date.now()}`, text: message },
                },
              ],
            },
          ],
        };
        const res = await request("/api/v1/channels/meta/webhook", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        await loadProfiles();
        out.textContent = pretty({
          seeded: true,
          channel_account_id: pageLike.id,
          channel_type: pageLike.channel_type,
          external_user_id: externalId,
          webhook_result: res,
          profiles_count: lastProfiles.length,
        });
      } catch (e) {
        out.textContent = String(e);
      }
    }

    async function runQaSweepFlow() {
      const out = $("outEscalationOps");
      out.textContent = "Running QA sweep flow...";
      try {
        if (isProdApiBase()) throw new Error("QA sweep flow disabled on production API base.");
        let selectedId = $("hfId").value.trim();
        let before = null;
        if (selectedId) {
          await loadHandoffQueue(true);
          before = (lastQueueItems || []).find((x) => x.id === selectedId) || null;
        }
        if (!before) {
          const breached = await request("/api/v1/admin/handoff?breached_only=true");
          const candidate = Array.isArray(breached && breached.items) && breached.items.length ? breached.items[0] : null;
          if (!candidate || !candidate.id) {
            throw new Error("No breached tickets found. Create or wait for an SLA breach, then rerun QA flow.");
          }
          selectedId = candidate.id;
          $("hfId").value = selectedId;
          await loadHandoffQueue(true);
          before = (lastQueueItems || []).find((x) => x.id === selectedId) || candidate;
        }
        const beforePriority = String(before.priority || "").toLowerCase();
        const beforeEsc = !!before.escalation_flag;
        if (!$("escSweepReason").value.trim()) {
          $("escSweepReason").value = `qa sweep validation ${new Date().toISOString()}`;
        }
        const sweep = await runEscalationSweep();
        const after = (lastQueueItems || []).find((x) => x.id === selectedId);
        out.textContent = pretty({
          qa_flow: "breached_ticket_sweep",
          selected_handoff_id: selectedId,
          before: {
            priority: beforePriority,
            escalation_flag: beforeEsc,
          },
          after: after
            ? {
                priority: after.priority,
                escalation_flag: !!after.escalation_flag,
                escalated_at: after.escalated_at || null,
              }
            : null,
          sweep_result: sweep,
          verified: !!(after && after.escalation_flag && ["high", "urgent"].includes(String(after.priority || "").toLowerCase())),
        });
      } catch (e) {
        out.textContent = String(e);
      }
    }

    async function runQaMergeFlow() {
      const out = $("outProfilesMerge");
      out.textContent = "Running QA merge flow...";
      try {
        if (isProdApiBase()) throw new Error("QA merge flow disabled on production API base.");
        const source = $("cpSourceId").value.trim();
        const target = $("cpTargetId").value.trim();
        if (!source || !target) throw new Error("Provide source and target profile IDs.");
        const beforeData = await loadProfiles();
        const beforeProfiles = Array.isArray(beforeData.profiles) ? beforeData.profiles : [];
        const beforeSource = beforeProfiles.find((p) => p.id === source) || null;
        const beforeTarget = beforeProfiles.find((p) => p.id === target) || null;
        if (!beforeSource || !beforeTarget) throw new Error("Source/target must exist in profile list before merge.");
        const merge = await mergeProfiles();
        const afterData = await loadProfiles();
        const afterProfiles = Array.isArray(afterData.profiles) ? afterData.profiles : [];
        const afterSource = afterProfiles.find((p) => p.id === source) || null;
        const afterTarget = afterProfiles.find((p) => p.id === target) || null;
        const beforeSourceConv = beforeSource.conversation_count || 0;
        const beforeSourceHandoff = beforeSource.handoff_count || 0;
        const beforeTargetConv = beforeTarget.conversation_count || 0;
        const beforeTargetHandoff = beforeTarget.handoff_count || 0;
        const afterTargetConv = afterTarget ? (afterTarget.conversation_count || 0) : null;
        const afterTargetHandoff = afterTarget ? (afterTarget.handoff_count || 0) : null;
        out.textContent = pretty({
          qa_flow: "merge_profiles_ownership_move",
          source_profile_id: source,
          target_profile_id: target,
          merge_result: merge,
          checks: {
            source_removed: !afterSource,
            target_conversations_before: beforeTargetConv,
            target_conversations_after: afterTargetConv,
            target_handoffs_before: beforeTargetHandoff,
            target_handoffs_after: afterTargetHandoff,
            expected_target_conversations_min: beforeTargetConv + beforeSourceConv,
            expected_target_handoffs_min: beforeTargetHandoff + beforeSourceHandoff,
            ownership_moved_conversations: afterTargetConv != null ? afterTargetConv >= (beforeTargetConv + Math.max(merge.moved_conversations || 0, beforeSourceConv)) : false,
            ownership_moved_handoffs: afterTargetHandoff != null ? afterTargetHandoff >= (beforeTargetHandoff + Math.max(merge.moved_handoffs || 0, beforeSourceHandoff)) : false,
          },
        });
      } catch (e) {
        out.textContent = String(e);
      }
    }

    $("saveToken").onclick = () => {
      localStorage.setItem("tenant_console_token", $("accessToken").value);
      localStorage.setItem("tenant_console_api_base", $("apiBase").value);
      alert("Saved.");
    };

    $("clearToken").onclick = () => {
      localStorage.removeItem("tenant_console_token");
      setToken("");
    };

    $("btnOnboard").onclick = async () => {
      const out = $("outOnboard");
      out.textContent = "Running...";
      try {
        const body = {
          tenant_name: $("obTenantName").value.trim(),
          admin_email: $("obAdminEmail").value.trim(),
          admin_password: $("obAdminPassword").value,
          compliance_level: "standard",
          bot_name: $("obBotName").value.trim(),
          allowed_origins: parseOrigins($("obAllowedOrigins").value),
        };
        const data = await request("/api/v1/tenant/onboard", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });
        out.textContent = pretty(data);
        if (data && data.access_token) setToken(data.access_token);
        if (data && data.bot_id) $("botId").value = data.bot_id;
      } catch (e) {
        out.textContent = String(e);
      }
    };

    $("btnLogin").onclick = async () => {
      const out = $("outLogin");
      out.textContent = "Running...";
      try {
        const body = {
          tenant_id: $("lgTenantId").value.trim(),
          email: $("lgEmail").value.trim(),
          password: $("lgPassword").value,
        };
        const data = await request("/api/v1/auth/login", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });
        out.textContent = pretty(data);
        if (data && data.access_token) setToken(data.access_token);
      } catch (e) {
        out.textContent = String(e);
      }
    };

    $("btnBots").onclick = async () => {
      const out = $("outBots");
      out.textContent = "Loading...";
      try {
        const data = await request("/api/v1/tenant/bots");
        out.textContent = pretty(data);
        if (Array.isArray(data) && data.length && data[0].id) {
          $("botId").value = data[0].id;
        }
      } catch (e) {
        out.textContent = String(e);
      }
    };

    $("btnSnippet").onclick = async () => {
      const out = $("outSnippet");
      out.textContent = "Loading...";
      try {
        const botId = $("botId").value.trim();
        if (!botId) throw new Error("Provide bot id first.");
        const data = await request(`/api/v1/tenant/embed/snippet?bot_id=${encodeURIComponent(botId)}`);
        out.textContent = data.snippet_html || pretty(data);
      } catch (e) {
        out.textContent = String(e);
      }
    };

    $("btnUpload").onclick = async () => {
      const out = $("outUpload");
      out.textContent = "Uploading...";
      try {
        const file = $("kgFile").files[0];
        if (!file) throw new Error("Pick a file first.");
        const fd = new FormData();
        fd.append("file", file);
        const data = await request("/api/v1/tenant/knowledge/upload", {
          method: "POST",
          body: fd,
        });
        out.textContent = pretty(data);
        if (data && data.document_id) $("kgDocId").value = data.document_id;
      } catch (e) {
        out.textContent = String(e);
      }
    };

    $("btnStatus").onclick = async () => {
      const out = $("outStatus");
      out.textContent = "Checking...";
      try {
        const data = await request("/api/v1/tenant/knowledge/status");
        out.textContent = pretty(data);
      } catch (e) {
        out.textContent = String(e);
      }
    };

    $("btnReindex").onclick = async () => {
      const out = $("outStatus");
      out.textContent = "Reindexing...";
      try {
        const docId = $("kgDocId").value.trim();
        if (!docId) throw new Error("Provide document id.");
        const data = await request("/api/v1/tenant/knowledge/reindex", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ document_id: docId }),
        });
        out.textContent = pretty(data);
      } catch (e) {
        out.textContent = String(e);
      }
    };

    $("btnHandoffList").onclick = () => loadHandoffQueue(false);
    $("hfAutoRefresh").onchange = () => setQueueAutoRefresh();
    $("hfSort").onchange = () => {
      if ($("queueTableWrap").style.display !== "none") loadHandoffQueue(true);
    };
    $("btnQuickOpenNew").onclick = () => {
      $("hfStatus").value = "new_open";
      $("hfEscalatedOnly").value = "false";
      $("hfBreachedOnly").value = "false";
      $("hfSort").value = "urgent_escalated";
      loadHandoffQueue(false);
    };
    $("btnQuickEscalated").onclick = () => {
      $("hfEscalatedOnly").value = "true";
      $("hfStatus").value = "new_open";
      $("hfSort").value = "urgent_escalated";
      loadHandoffQueue(false);
    };
    $("btnQuickResetQueue").onclick = () => {
      $("hfStatus").value = "";
      $("hfAssignedTo").value = "";
      $("hfPriorityFilter").value = "";
      $("hfBreachedOnly").value = "false";
      $("hfEscalatedOnly").value = "false";
      $("hfSort").value = "urgent_escalated";
      loadHandoffQueue(false);
    };

    $("btnHandoffPatch").onclick = async () => {
      const out = $("outHandoffPatch");
      out.textContent = "Patching...";
      try {
        const handoffId = $("hfId").value.trim();
        if (!handoffId) throw new Error("Provide handoff id.");
        const body = {};
        const status = $("hfSetStatus").value.trim();
        const assignTo = $("hfAssignTo").value.trim();
        const priority = $("hfPriority").value.trim();
        const resolutionNote = $("hfResolutionNote").value.trim();
        if (status) body.status = status;
        if (assignTo) body.assigned_to_user_id = assignTo;
        if (priority) body.priority = priority;
        if (resolutionNote) body.resolution_note = resolutionNote;
        if (!Object.keys(body).length) throw new Error("Pick at least one field to update.");

        const data = await request(`/api/v1/admin/handoff/${encodeURIComponent(handoffId)}`, {
          method: "PATCH",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });
        out.textContent = pretty(data);
      } catch (e) {
        out.textContent = String(e);
      }
    };

    $("btnHandoffClaim").onclick = async () => {
      const out = $("outHandoffAgent");
      out.textContent = "Claiming...";
      try {
        const handoffId = $("hfId").value.trim();
        if (!handoffId) throw new Error("Provide handoff id.");
        const claimUser = $("hfClaimUser").value.trim();
        const body = {};
        if (claimUser) body.assigned_to_user_id = claimUser;
        const data = await request(`/api/v1/admin/handoff/${encodeURIComponent(handoffId)}/claim`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });
        out.textContent = pretty(data);
      } catch (e) {
        out.textContent = String(e);
      }
    };

    $("btnHandoffReply").onclick = async () => {
      const out = $("outHandoffAgent");
      out.textContent = "Sending agent reply...";
      try {
        const handoffId = $("hfId").value.trim();
        if (!handoffId) throw new Error("Provide handoff id.");
        const review = await fetchReplyReview("none");
        renderReplyReview(review);
        if (review.requires_override && !$("hfSendOverride").checked) {
          throw new Error("High-risk flag detected. Tick 'Send anyway if high-risk flagged' to proceed.");
        }
        const message = $("hfAgentReply").value.trim();
        if (!message) throw new Error("Write an agent reply message.");
        const markPendingCustomer = $("hfMarkPending").value === "true";
        const body = {
          message,
          mark_pending_customer: markPendingCustomer,
        };
        const data = await request(`/api/v1/admin/handoff/${encodeURIComponent(handoffId)}/reply`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });
        out.textContent = pretty(data);
        $("hfAgentReply").value = "";
        $("hfSendOverride").checked = false;
        lastReplyReview = null;
        if ($("convId").value.trim()) {
          $("btnLoadConversation").click();
        }
      } catch (e) {
        out.textContent = String(e);
      }
    };

    $("btnReviewReply").onclick = async () => {
      const out = $("outReplyReview");
      out.textContent = "Reviewing...";
      try {
        const data = await fetchReplyReview("none");
        renderReplyReview(data);
      } catch (e) {
        out.textContent = String(e);
      }
    };
    $("btnRewriteShorter").onclick = async () => {
      const out = $("outReplyReview");
      out.textContent = "Rewriting (shorter)...";
      try {
        const data = await fetchReplyReview("shorter");
        $("hfAgentReply").value = data.improved_draft || $("hfAgentReply").value;
        renderReplyReview(data);
      } catch (e) {
        out.textContent = String(e);
      }
    };
    $("btnRewriteFriendlier").onclick = async () => {
      const out = $("outReplyReview");
      out.textContent = "Rewriting (friendlier)...";
      try {
        const data = await fetchReplyReview("friendlier");
        $("hfAgentReply").value = data.improved_draft || $("hfAgentReply").value;
        renderReplyReview(data);
      } catch (e) {
        out.textContent = String(e);
      }
    };
    $("btnRewriteFormal").onclick = async () => {
      const out = $("outReplyReview");
      out.textContent = "Rewriting (formal)...";
      try {
        const data = await fetchReplyReview("formal");
        $("hfAgentReply").value = data.improved_draft || $("hfAgentReply").value;
        renderReplyReview(data);
      } catch (e) {
        out.textContent = String(e);
      }
    };

    async function setAIToggle(aiPaused) {
      const out = $("outHandoffAgent");
      out.textContent = aiPaused ? "Pausing AI..." : "Resuming AI...";
      try {
        const handoffId = $("hfId").value.trim();
        if (!handoffId) throw new Error("Provide handoff id.");
        const data = await request(`/api/v1/admin/handoff/${encodeURIComponent(handoffId)}/ai-toggle`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ ai_paused: aiPaused }),
        });
        out.textContent = pretty(data);
      } catch (e) {
        out.textContent = String(e);
      }
    }

    $("btnPauseAI").onclick = () => setAIToggle(true);
    $("btnResumeAI").onclick = () => setAIToggle(false);
    $("btnAddInternalNote").onclick = async () => {
      const out = $("outHandoffAgent");
      out.textContent = "Saving internal note...";
      try {
        const handoffId = $("hfId").value.trim();
        if (!handoffId) throw new Error("Provide handoff id.");
        const note = $("hfInternalNote").value.trim();
        if (!note) throw new Error("Write an internal note first.");
        const data = await request(`/api/v1/admin/handoff/${encodeURIComponent(handoffId)}/notes`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ content: note }),
        });
        $("hfInternalNote").value = "";
        out.textContent = pretty(data);
        await loadHandoffNotes();
      } catch (e) {
        out.textContent = String(e);
      }
    };
    $("btnLoadNotes").onclick = async () => {
      const out = $("outHandoffAgent");
      out.textContent = "Loading notes...";
      try {
        const data = await loadHandoffNotes();
        out.textContent = pretty({ handoff_id: data.handoff_id, count: data.count });
      } catch (e) {
        out.textContent = String(e);
        renderNotesTimeline(null);
      }
    };

    $("btnLoadConversation").onclick = async () => {
      const out = $("outConversationMeta");
      out.textContent = "Loading conversation...";
      try {
        const conversationId = $("convId").value.trim();
        if (!conversationId) throw new Error("Provide conversation id.");
        const data = await request(
          `/api/v1/admin/conversations/${encodeURIComponent(conversationId)}/messages?limit=200&offset=0`
        );
        out.textContent = `Conversation: ${data.conversation_id}\nMessages: ${Array.isArray(data.messages) ? data.messages.length : 0}`;
        renderConversationThread(data);
      } catch (e) {
        out.textContent = String(e);
        renderConversationThread(null);
      }
    };

    $("btnLoadProdMetrics").onclick = async () => {
      const out = $("outProdMetrics");
      out.textContent = "Loading metrics...";
      try {
        const data = await request("/api/v1/admin/handoff/metrics");
        out.textContent = pretty({ tenant_id: data.tenant_id, as_of: data.as_of });
        renderProductivityMetrics(data);
      } catch (e) {
        out.textContent = String(e);
        renderProductivityMetrics(null);
      }
    };

    $("btnProfilesList").onclick = () => loadProfiles();
    $("btnProfilesMerge").onclick = async () => {
      try { await mergeProfiles(); } catch (_) {}
    };
    $("btnQaMergeFlow").onclick = () => runQaMergeFlow();
    $("btnSeedProfileData").onclick = () => seedProfileActivity();

    $("btnEscMetrics").onclick = () => loadEscalationMetrics();
    $("btnEscSweep").onclick = async () => {
      try { await runEscalationSweep(); } catch (_) {}
    };
    $("btnQaSweepFlow").onclick = () => runQaSweepFlow();
    $("btnLoadOpsMonitor").onclick = () => loadOpsMonitor();
    $("btnLoadOpsAudit").onclick = () => loadOpsAudit();
    $("apiBase").onchange = () => applyQaAvailability();

    (function bootstrap() {
      const savedToken = localStorage.getItem("tenant_console_token");
      const savedBase = localStorage.getItem("tenant_console_api_base");
      if (savedToken) setToken(savedToken);
      if (savedBase) $("apiBase").value = savedBase;
      $("hfStatus").value = "new_open";
      $("hfSort").value = "urgent_escalated";
      $("hfEscalatedOnly").value = "false";
      if (!$("escSweepReason").value.trim()) $("escSweepReason").value = "scheduled SLA triage sweep";
      if (!$("cpMergeReason").value.trim()) $("cpMergeReason").value = "dedupe duplicate customer identities";
      applyQaAvailability();
      loadOpsAudit();
      setQueueAutoRefresh();
    })();
  </script>
</body>
</html>

